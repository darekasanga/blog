<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>EMPEROR.NEWS | AI COVE-kun</title>
  <link rel="stylesheet" href="../assets/styles.css" />
</head>
<body class="home-page">
  <header class="site-header">
    <div class="inner">
      <div class="brand">
        <div class="brand-mark" aria-hidden="true"></div>
        <div>
          <p class="brand-kicker">BLOG</p>
          <p class="brand-title" data-site-title>EMPEROR.NEWS</p>
        </div>
      </div>
      <nav class="nav-links" aria-label="メインナビゲーション">
        <a href="../index.html" class="nav-link">トップ</a>
        <a href="../admin/index.html" class="nav-link">管理ページ</a>
        <a href="index.html" class="nav-link active">AI COVE-kun</a>
      </nav>
    </div>
  </header>

  <main>
    <section class="section">
      <div class="inner">
        <p class="kicker">AI COVE-kun</p>
        <h1>多言語デコード・アシスタント</h1>
        <p class="lead">原文を入力すると、指定フォーマットでデコード結果を整形して表示します。</p>
        <p class="muted-text">
          AI COVEくん解析では、左側は手書き入力から文字解析を行うため、端末機能で文字認識はしない。
          右側の赤ペン修正では、赤枠表示をタップし修正を赤ペンでしたものを手書き文字判定により、蓄積データまたはOCRにより出力項目に出力する。
        </p>
        <div class="info-grid" style="align-items: stretch;">
          <form class="info-card info-card--sticky" id="decode-form">
            <div class="field">
              <label for="handwriting-canvas">ORIGINAL_INPUT (筆記入力)</label>
              <div class="handwriting-panel">
                <canvas id="handwriting-canvas" width="640" height="280" aria-label="原文の筆記入力エリア"></canvas>
                <div class="handwriting-actions">
                  <p class="muted-text">左側に手書きで文章を入力してください。描き終わったら「解読」を押してください。</p>
                  <button class="btn ghost" type="button" id="clear-drawing">筆記をクリア</button>
                </div>
              </div>
            </div>
            <p class="decode-status" id="decode-status" role="status" aria-live="polite"></p>
            <div class="form-actions">
              <button class="btn primary" type="submit">解読</button>
              <button class="btn ghost" type="button" id="clear-button">Clear</button>
            </div>
          </form>

          <div class="info-card">
            <div class="section-header">
              <div>
                <p class="kicker">Decoded</p>
                <h2>レイヤー解析プレビュー</h2>
              </div>
            </div>
            <div class="output-panel layered-output">
              <div class="layered-output__stack" aria-label="解析レイヤースタック">
                <img id="source-preview" alt="入力画像プレビュー" />
                <canvas id="analysis-layer" aria-label="解析レイヤー"></canvas>
                <canvas id="correction-layer" aria-label="赤ペン修正レイヤー"></canvas>
                <div class="layered-output__characters" id="character-annotations" aria-label="文字ごとの解読結果"></div>
                <div class="layered-output__placeholder" id="layered-placeholder">
                  原文画像がここに表示されます
                </div>
              </div>
              <div class="layered-output__meta">
                <p class="muted-text">原画像に対して解析結果（ハイライト）と赤ペン修正を重ねて確認できます。</p>
                <div class="layered-output__actions">
                  <button class="btn ghost" type="button" id="toggle-analysis">解析レイヤー切替</button>
                  <button class="btn ghost" type="button" id="clear-corrections">赤ペンをクリア</button>
                </div>
              </div>
              <pre class="decoded-text" id="decoded-output">[DECODED_OUTPUT]
（ここに結果が表示されます）</pre>
            </div>
          </div>
        </div>
      </div>
    </section>

    <section class="section muted">
      <div class="inner">
        <div class="section-header">
          <div>
            <p class="kicker">Guideline</p>
            <h2>運用ルールの要点</h2>
          </div>
        </div>
        <div class="info-grid">
          <div class="info-card">
            <h3>優先順位</h3>
            <ul>
              <li>確定済みの学習ルールを最優先で適用。</li>
              <li>競合があれば文脈に合うものを選択。</li>
              <li>確信が低い場合は原文を保持。</li>
            </ul>
          </div>
          <div class="info-card">
            <h3>出力ルール</h3>
            <ul>
              <li>返答は <strong>[DECODED_OUTPUT]</strong> のみ。</li>
              <li>説明や補足は出力に含めない。</li>
              <li>多言語の混在を維持。</li>
            </ul>
          </div>
        </div>
      </div>
    </section>
  </main>

  <footer class="site-footer">
    <div class="inner footer-grid">
      <div>
        <p class="brand-title" data-site-title>EMPEROR.NEWS</p>
        <p class="muted-text" data-footer-description>シンプルで統一感のあるブログ体験を届けます。</p>
      </div>
      <div id="site-theme-picker" class="footer-theme-picker" aria-label="表示テーマ選択"></div>
    </div>
  </footer>

  <script>
    const form = document.getElementById('decode-form');
    const handwritingCanvas = document.getElementById('handwriting-canvas');
    const clearDrawingButton = document.getElementById('clear-drawing');
    const output = document.getElementById('decoded-output');
    const status = document.getElementById('decode-status');
    const clearButton = document.getElementById('clear-button');
    const sourcePreview = document.getElementById('source-preview');
    const analysisCanvas = document.getElementById('analysis-layer');
    const correctionCanvas = document.getElementById('correction-layer');
    const toggleAnalysisButton = document.getElementById('toggle-analysis');
    const clearCorrectionsButton = document.getElementById('clear-corrections');
    const layeredPlaceholder = document.getElementById('layered-placeholder');
    const characterAnnotations = document.getElementById('character-annotations');
    const handwritingContext = handwritingCanvas.getContext('2d');
    const analysisContext = analysisCanvas.getContext('2d');
    const correctionContext = correctionCanvas.getContext('2d');
    let isDrawing = false;
    let hasDrawing = false;
    let lastPoint = null;
    let isAnnotating = false;
    let lastCorrectionPoint = null;
    let analysisVisible = true;
    let lastOcrData = null;
    let hasCorrections = false;
    let activeAnnotation = null;
    let activeCorrectionStroke = false;

    const resizeCanvasForDisplay = () => {
      const ratio = window.devicePixelRatio || 1;
      const { width, height } = handwritingCanvas.getBoundingClientRect();
      handwritingCanvas.width = Math.max(1, Math.floor(width * ratio));
      handwritingCanvas.height = Math.max(1, Math.floor(height * ratio));
      handwritingContext.setTransform(ratio, 0, 0, ratio, 0, 0);
      handwritingContext.lineWidth = 4;
      handwritingContext.lineCap = 'round';
      handwritingContext.lineJoin = 'round';
      handwritingContext.strokeStyle = '#111';
      handwritingContext.fillStyle = '#fff';
      handwritingContext.fillRect(0, 0, width, height);
      hasDrawing = false;
    };

    const syncLayerCanvases = () => {
      const ratio = window.devicePixelRatio || 1;
      const rect = sourcePreview.getBoundingClientRect();
      if (!rect.width || !rect.height) {
        return;
      }
      [analysisCanvas, correctionCanvas].forEach((canvas) => {
        canvas.width = Math.max(1, Math.floor(rect.width * ratio));
        canvas.height = Math.max(1, Math.floor(rect.height * ratio));
        canvas.style.width = `${rect.width}px`;
        canvas.style.height = `${rect.height}px`;
      });
      analysisContext.setTransform(ratio, 0, 0, ratio, 0, 0);
      correctionContext.setTransform(ratio, 0, 0, ratio, 0, 0);
      correctionContext.lineWidth = 3;
      correctionContext.lineCap = 'round';
      correctionContext.lineJoin = 'round';
      correctionContext.strokeStyle = '#e11d48';
    };

    const resetCanvas = () => {
      const { width, height } = handwritingCanvas.getBoundingClientRect();
      handwritingContext.setTransform(window.devicePixelRatio || 1, 0, 0, window.devicePixelRatio || 1, 0, 0);
      handwritingContext.fillStyle = '#fff';
      handwritingContext.fillRect(0, 0, width, height);
      hasDrawing = false;
    };

    const startDrawing = (event) => {
      isDrawing = true;
      const rect = handwritingCanvas.getBoundingClientRect();
      lastPoint = {
        x: event.clientX - rect.left,
        y: event.clientY - rect.top,
      };
    };

    const drawStroke = (event) => {
      if (!isDrawing || !lastPoint) return;
      const rect = handwritingCanvas.getBoundingClientRect();
      const currentPoint = {
        x: event.clientX - rect.left,
        y: event.clientY - rect.top,
      };
      handwritingContext.beginPath();
      handwritingContext.moveTo(lastPoint.x, lastPoint.y);
      handwritingContext.lineTo(currentPoint.x, currentPoint.y);
      handwritingContext.stroke();
      lastPoint = currentPoint;
      hasDrawing = true;
    };

    const stopDrawing = () => {
      isDrawing = false;
      lastPoint = null;
    };

    const startCorrection = (event) => {
      isAnnotating = true;
      const rect = correctionCanvas.getBoundingClientRect();
      lastCorrectionPoint = {
        x: event.clientX - rect.left,
        y: event.clientY - rect.top,
      };
    };

    const drawCorrection = (event) => {
      if (!isAnnotating || !lastCorrectionPoint) return;
      const rect = correctionCanvas.getBoundingClientRect();
      const currentPoint = {
        x: event.clientX - rect.left,
        y: event.clientY - rect.top,
      };
      correctionContext.beginPath();
      correctionContext.moveTo(lastCorrectionPoint.x, lastCorrectionPoint.y);
      correctionContext.lineTo(currentPoint.x, currentPoint.y);
      correctionContext.stroke();
      lastCorrectionPoint = currentPoint;
      hasCorrections = true;
      if (activeAnnotation) {
        activeCorrectionStroke = true;
      }
    };

    const stopCorrection = async () => {
      isAnnotating = false;
      lastCorrectionPoint = null;
      if (activeAnnotation && activeCorrectionStroke) {
        announceStatus('赤ペン修正を再判定中…');
        const updatedText = await runOcrForRegion(activeAnnotation.bbox);
        if (updatedText) {
          activeAnnotation.label.textContent = updatedText;
          activeAnnotation.element.classList.remove('character-annotation--registered');
          announceStatus(`修正結果「${updatedText}」を表示しました。`);
        } else {
          announceStatus('修正結果が判定できませんでした。');
        }
        activeAnnotation.element.classList.remove('character-annotation--active');
        activeAnnotation = null;
        activeCorrectionStroke = false;
      }
    };

    const clearLayer = (context) => {
      context.clearRect(0, 0, context.canvas.width, context.canvas.height);
    };

    const clearCharacterAnnotations = () => {
      characterAnnotations.innerHTML = '';
      activeAnnotation = null;
    };

    const announceStatus = (message) => {
      status.textContent = message;
    };

    const buildCompositeCanvas = () => {
      const compositeCanvas = document.createElement('canvas');
      compositeCanvas.width = handwritingCanvas.width;
      compositeCanvas.height = handwritingCanvas.height;
      const compositeContext = compositeCanvas.getContext('2d');
      compositeContext.drawImage(handwritingCanvas, 0, 0);
      if (hasCorrections && correctionCanvas.width && correctionCanvas.height) {
        const scaleX = handwritingCanvas.width / correctionCanvas.width;
        const scaleY = handwritingCanvas.height / correctionCanvas.height;
        compositeContext.save();
        compositeContext.scale(scaleX, scaleY);
        compositeContext.drawImage(correctionCanvas, 0, 0);
        compositeContext.restore();
      }
      return compositeCanvas;
    };

    const normalizeBbox = (bbox, padding = 6) => {
      const maxWidth = handwritingCanvas.width;
      const maxHeight = handwritingCanvas.height;
      const x0 = Math.max(0, Math.floor(bbox.x0 - padding));
      const y0 = Math.max(0, Math.floor(bbox.y0 - padding));
      const x1 = Math.min(maxWidth, Math.ceil(bbox.x1 + padding));
      const y1 = Math.min(maxHeight, Math.ceil(bbox.y1 + padding));
      return { x0, y0, x1, y1 };
    };

    const runOcrForRegion = async (bbox) => {
      if (!window.Tesseract) return '';
      const normalized = normalizeBbox(bbox);
      const width = Math.max(1, normalized.x1 - normalized.x0);
      const height = Math.max(1, normalized.y1 - normalized.y0);
      const compositeCanvas = buildCompositeCanvas();
      const cropCanvas = document.createElement('canvas');
      cropCanvas.width = width;
      cropCanvas.height = height;
      const cropContext = cropCanvas.getContext('2d');
      cropContext.drawImage(
        compositeCanvas,
        normalized.x0,
        normalized.y0,
        width,
        height,
        0,
        0,
        width,
        height,
      );
      const result = await window.Tesseract.recognize(cropCanvas.toDataURL('image/png'), 'jpn+eng');
      return result.data.text.trim();
    };

    const renderAnalysisLayer = (ocrData) => {
      lastOcrData = ocrData;
      clearLayer(analysisContext);
      clearCharacterAnnotations();
      const entries = ocrData?.symbols?.length ? ocrData.symbols : ocrData?.words || [];
      if (!entries.length) {
        return;
      }
      const rect = analysisCanvas.getBoundingClientRect();
      const scaleX = rect.width / handwritingCanvas.width;
      const scaleY = rect.height / handwritingCanvas.height;
      analysisContext.fillStyle = 'rgba(239, 68, 68, 0.18)';
      analysisContext.strokeStyle = 'rgba(239, 68, 68, 0.9)';
      analysisContext.lineWidth = 1.5;
      entries.forEach((entry) => {
        if (!entry.bbox) return;
        const width = (entry.bbox.x1 - entry.bbox.x0) * scaleX;
        const height = (entry.bbox.y1 - entry.bbox.y0) * scaleY;
        const x = entry.bbox.x0 * scaleX;
        const y = entry.bbox.y0 * scaleY;
        analysisContext.fillRect(x, y, width, height);
        analysisContext.strokeRect(x, y, width, height);
      });
    };

    const renderCharacterAnnotations = (ocrData) => {
      clearCharacterAnnotations();
      if (!ocrData || !ocrData.symbols || !ocrData.symbols.length) {
        return;
      }
      const rect = analysisCanvas.getBoundingClientRect();
      const scaleX = rect.width / handwritingCanvas.width;
      const scaleY = rect.height / handwritingCanvas.height;
      ocrData.symbols.forEach((symbol, index) => {
        if (!symbol.bbox) return;
        const text = (symbol.text || '').trim();
        if (!text) return;
        const width = (symbol.bbox.x1 - symbol.bbox.x0) * scaleX;
        const height = (symbol.bbox.y1 - symbol.bbox.y0) * scaleY;
        const x = symbol.bbox.x0 * scaleX;
        const y = symbol.bbox.y0 * scaleY;
        const annotation = document.createElement('button');
        annotation.type = 'button';
        annotation.className = 'character-annotation';
        annotation.style.left = `${x}px`;
        annotation.style.top = `${y}px`;
        annotation.style.width = `${width}px`;
        annotation.style.height = `${height}px`;
        annotation.dataset.index = String(index);
        annotation.dataset.bbox = JSON.stringify(symbol.bbox);
        const label = document.createElement('span');
        label.className = 'character-annotation__label';
        label.textContent = text;
        annotation.appendChild(label);
        label.addEventListener('click', (event) => {
          event.stopPropagation();
          annotation.classList.add('character-annotation--registered');
          announceStatus(`判定「${label.textContent}」を登録しました。`);
        });
        annotation.addEventListener('click', () => {
          if (activeAnnotation?.element) {
            activeAnnotation.element.classList.remove('character-annotation--active');
          }
          activeAnnotation = {
            element: annotation,
            label,
            bbox: symbol.bbox,
          };
          activeCorrectionStroke = false;
          announceStatus('赤枠の上から赤ペンで修正してください。');
          annotation.classList.add('character-annotation--active');
        });
        characterAnnotations.appendChild(annotation);
      });
    };

    const updatePreviewImage = (imageData) => {
      if (!imageData) {
        sourcePreview.removeAttribute('src');
        layeredPlaceholder.hidden = false;
        clearLayer(analysisContext);
        clearLayer(correctionContext);
        clearCharacterAnnotations();
        hasCorrections = false;
        return;
      }
      sourcePreview.src = imageData;
      layeredPlaceholder.hidden = true;
      sourcePreview.onload = () => {
        syncLayerCanvases();
      };
      syncLayerCanvases();
    };

    handwritingCanvas.addEventListener('pointerdown', (event) => {
      event.preventDefault();
      handwritingCanvas.setPointerCapture(event.pointerId);
      startDrawing(event);
    });
    handwritingCanvas.addEventListener('pointermove', (event) => {
      event.preventDefault();
      drawStroke(event);
    });
    handwritingCanvas.addEventListener('pointerup', stopDrawing);
    handwritingCanvas.addEventListener('pointercancel', stopDrawing);
    handwritingCanvas.addEventListener('pointerleave', stopDrawing);
    handwritingCanvas.addEventListener(
      'touchstart',
      (event) => {
        event.preventDefault();
      },
      { passive: false },
    );
    handwritingCanvas.addEventListener(
      'touchmove',
      (event) => {
        event.preventDefault();
      },
      { passive: false },
    );

    correctionCanvas.addEventListener('pointerdown', (event) => {
      event.preventDefault();
      correctionCanvas.setPointerCapture(event.pointerId);
      startCorrection(event);
    });
    correctionCanvas.addEventListener('pointermove', (event) => {
      event.preventDefault();
      drawCorrection(event);
    });
    correctionCanvas.addEventListener('pointerup', stopCorrection);
    correctionCanvas.addEventListener('pointercancel', stopCorrection);
    correctionCanvas.addEventListener('pointerleave', stopCorrection);

    clearDrawingButton.addEventListener('click', () => {
      resetCanvas();
      updatePreviewImage('');
      lastOcrData = null;
      status.textContent = '筆記入力をクリアしました。';
    });

    const extractBlock = (label, text) => {
      const pattern = new RegExp(`\\[${label}\\]([\\s\\S]*?)(?=\\n\\[[A-Z_]+\\]|$)`, 'i');
      const match = text.match(pattern);
      return match ? match[1].trim() : '';
    };

    const buildCompositeImage = () => {
      if (!hasCorrections || !correctionCanvas.width || !correctionCanvas.height) {
        return handwritingCanvas.toDataURL('image/png');
      }
      return buildCompositeCanvas().toDataURL('image/png');
    };

    const runOcr = async () => {
      if (!hasDrawing) {
        return null;
      }
      status.textContent = '解読中…';
      const baseImageData = handwritingCanvas.toDataURL('image/png');
      updatePreviewImage(baseImageData);
      const ocrImageData = buildCompositeImage();
      if (!window.Tesseract) {
        status.textContent = 'OCR ライブラリの読み込みに失敗しました。';
        return null;
      }
      const result = await window.Tesseract.recognize(ocrImageData, 'jpn+eng', {
        logger: (message) => {
          if (message.status === 'recognizing text') {
            status.textContent = `解読中…${Math.round(message.progress * 100)}%`;
          }
        },
      });
      return {
        text: result.data.text.trim(),
        data: result.data,
      };
    };

    form.addEventListener('submit', async (event) => {
      event.preventDefault();
      const ocrResult = await runOcr();
      const rawText = ocrResult?.text ?? '';
      const blockInput = extractBlock('ORIGINAL_INPUT', rawText) || rawText;
      const resultText = blockInput || '（入力がありません）';

      output.textContent = `[DECODED_OUTPUT]\n${resultText}`;
      if (ocrResult?.data) {
        renderAnalysisLayer(ocrResult.data);
        renderCharacterAnnotations(ocrResult.data);
      } else {
        lastOcrData = null;
        clearLayer(analysisContext);
        clearCharacterAnnotations();
      }
      if (!rawText && !hasDrawing) {
        status.textContent = '筆記入力がありません。';
      } else {
        status.textContent = 'デコードが完了しました。';
      }
    });

    clearButton.addEventListener('click', () => {
      resetCanvas();
      output.textContent = '[DECODED_OUTPUT]\n（ここに結果が表示されます）';
      updatePreviewImage('');
      lastOcrData = null;
      clearLayer(analysisContext);
      clearLayer(correctionContext);
      clearCharacterAnnotations();
      hasCorrections = false;
      status.textContent = '';
    });

    toggleAnalysisButton.addEventListener('click', () => {
      analysisVisible = !analysisVisible;
      analysisCanvas.style.opacity = analysisVisible ? '1' : '0';
    });

    clearCorrectionsButton.addEventListener('click', () => {
      clearLayer(correctionContext);
      hasCorrections = false;
    });

    window.addEventListener('resize', () => {
      resizeCanvasForDisplay();
      syncLayerCanvases();
      if (lastOcrData) {
        renderAnalysisLayer(lastOcrData);
        renderCharacterAnnotations(lastOcrData);
      }
    });
    resizeCanvasForDisplay();
  </script>
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5.1.1/dist/tesseract.min.js" defer></script>
</body>
</html>
