<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>EMPEROR.NEWS | AI COVE-kun</title>
  <link rel="stylesheet" href="../assets/styles.css" />
</head>
<body class="home-page">
  <header class="site-header">
    <div class="inner">
      <div class="brand">
        <div class="brand-mark" aria-hidden="true"></div>
        <div>
          <p class="brand-kicker">BLOG</p>
          <p class="brand-title" data-site-title>EMPEROR.NEWS</p>
        </div>
      </div>
      <nav class="nav-links" aria-label="メインナビゲーション">
        <a href="../index.html" class="nav-link">トップ</a>
        <a href="../admin/index.html" class="nav-link">管理ページ</a>
        <a href="index.html" class="nav-link active">AI COVE-kun</a>
      </nav>
    </div>
  </header>

  <main>
    <section class="section">
      <div class="inner">
        <p class="kicker">AI COVE-kun</p>
        <h1>多言語デコード・アシスタント</h1>
        <p class="lead">原文を入力すると、指定フォーマットでデコード結果を整形して表示します。</p>
        <div class="info-grid" style="align-items: stretch;">
          <form class="info-card" id="decode-form">
            <div class="field">
              <label for="handwriting-canvas">ORIGINAL_INPUT (筆記入力)</label>
              <div class="handwriting-panel">
                <canvas id="handwriting-canvas" width="640" height="280" aria-label="原文の筆記入力エリア"></canvas>
                <div class="handwriting-actions">
                  <p class="muted-text">左側に手書きで文章を入力してください。描き終わったら「解読」を押してください。</p>
                  <button class="btn ghost" type="button" id="clear-drawing">筆記をクリア</button>
                </div>
              </div>
            </div>
            <p class="decode-status" id="decode-status" role="status" aria-live="polite"></p>
            <div class="form-actions">
              <button class="btn primary" type="submit">解読</button>
              <button class="btn ghost" type="button" id="clear-button">Clear</button>
            </div>
          </form>

          <div class="info-card">
            <div class="section-header">
              <div>
                <p class="kicker">Decoded</p>
                <h2>レイヤー解析プレビュー</h2>
              </div>
            </div>
            <div class="output-panel layered-output">
              <div class="layered-output__stack" aria-label="解析レイヤースタック">
                <img id="source-preview" alt="入力画像プレビュー" />
                <canvas id="analysis-layer" aria-label="解析レイヤー"></canvas>
                <canvas id="correction-layer" aria-label="赤ペン修正レイヤー"></canvas>
                <div class="layered-output__characters" id="character-annotations" aria-label="文字ごとの解読結果"></div>
                <div class="layered-output__placeholder" id="layered-placeholder">
                  原文画像がここに表示されます
                </div>
              </div>
              <div class="layered-output__meta">
                <p class="muted-text">原画像に対して解析結果（ハイライト）と赤ペン修正を重ねて確認できます。</p>
                <div class="layered-output__actions">
                  <button class="btn ghost" type="button" id="toggle-analysis">解析レイヤー切替</button>
                  <button class="btn ghost" type="button" id="clear-corrections">赤ペンをクリア</button>
                </div>
              </div>
              <pre class="decoded-text" id="decoded-output">[DECODED_OUTPUT]
（ここに結果が表示されます）</pre>
            </div>
          </div>
        </div>
      </div>
    </section>

    <section class="section muted">
      <div class="inner">
        <div class="section-header">
          <div>
            <p class="kicker">Guideline</p>
            <h2>運用ルールの要点</h2>
          </div>
        </div>
        <div class="info-grid">
          <div class="info-card">
            <h3>優先順位</h3>
            <ul>
              <li>確定済みの学習ルールを最優先で適用。</li>
              <li>競合があれば文脈に合うものを選択。</li>
              <li>確信が低い場合は原文を保持。</li>
            </ul>
          </div>
          <div class="info-card">
            <h3>出力ルール</h3>
            <ul>
              <li>返答は <strong>[DECODED_OUTPUT]</strong> のみ。</li>
              <li>説明や補足は出力に含めない。</li>
              <li>多言語の混在を維持。</li>
            </ul>
          </div>
        </div>
      </div>
    </section>
  </main>

  <footer class="site-footer">
    <div class="inner footer-grid">
      <div>
        <p class="brand-title" data-site-title>EMPEROR.NEWS</p>
        <p class="muted-text" data-footer-description>シンプルで統一感のあるブログ体験を届けます。</p>
      </div>
      <div id="site-theme-picker" class="footer-theme-picker" aria-label="表示テーマ選択"></div>
    </div>
  </footer>

  <script>
    const form = document.getElementById('decode-form');
    const handwritingCanvas = document.getElementById('handwriting-canvas');
    const clearDrawingButton = document.getElementById('clear-drawing');
    const output = document.getElementById('decoded-output');
    const status = document.getElementById('decode-status');
    const clearButton = document.getElementById('clear-button');
    const sourcePreview = document.getElementById('source-preview');
    const analysisCanvas = document.getElementById('analysis-layer');
    const correctionCanvas = document.getElementById('correction-layer');
    const toggleAnalysisButton = document.getElementById('toggle-analysis');
    const clearCorrectionsButton = document.getElementById('clear-corrections');
    const layeredPlaceholder = document.getElementById('layered-placeholder');
    const characterAnnotations = document.getElementById('character-annotations');
    const handwritingContext = handwritingCanvas.getContext('2d');
    const analysisContext = analysisCanvas.getContext('2d');
    const correctionContext = correctionCanvas.getContext('2d');
    let isDrawing = false;
    let hasDrawing = false;
    let lastPoint = null;
    let isAnnotating = false;
    let lastCorrectionPoint = null;
    let analysisVisible = true;
    let lastOcrData = null;
    let hasCorrections = false;

    const resizeCanvasForDisplay = () => {
      const ratio = window.devicePixelRatio || 1;
      const { width, height } = handwritingCanvas.getBoundingClientRect();
      handwritingCanvas.width = Math.max(1, Math.floor(width * ratio));
      handwritingCanvas.height = Math.max(1, Math.floor(height * ratio));
      handwritingContext.setTransform(ratio, 0, 0, ratio, 0, 0);
      handwritingContext.lineWidth = 4;
      handwritingContext.lineCap = 'round';
      handwritingContext.lineJoin = 'round';
      handwritingContext.strokeStyle = '#111';
      handwritingContext.fillStyle = '#fff';
      handwritingContext.fillRect(0, 0, width, height);
      hasDrawing = false;
    };

    const syncLayerCanvases = () => {
      const ratio = window.devicePixelRatio || 1;
      const rect = sourcePreview.getBoundingClientRect();
      if (!rect.width || !rect.height) {
        return;
      }
      [analysisCanvas, correctionCanvas].forEach((canvas) => {
        canvas.width = Math.max(1, Math.floor(rect.width * ratio));
        canvas.height = Math.max(1, Math.floor(rect.height * ratio));
        canvas.style.width = `${rect.width}px`;
        canvas.style.height = `${rect.height}px`;
      });
      analysisContext.setTransform(ratio, 0, 0, ratio, 0, 0);
      correctionContext.setTransform(ratio, 0, 0, ratio, 0, 0);
      correctionContext.lineWidth = 3;
      correctionContext.lineCap = 'round';
      correctionContext.lineJoin = 'round';
      correctionContext.strokeStyle = '#e11d48';
    };

    const resetCanvas = () => {
      const { width, height } = handwritingCanvas.getBoundingClientRect();
      handwritingContext.setTransform(window.devicePixelRatio || 1, 0, 0, window.devicePixelRatio || 1, 0, 0);
      handwritingContext.fillStyle = '#fff';
      handwritingContext.fillRect(0, 0, width, height);
      hasDrawing = false;
    };

    const startDrawing = (event) => {
      isDrawing = true;
      const rect = handwritingCanvas.getBoundingClientRect();
      lastPoint = {
        x: event.clientX - rect.left,
        y: event.clientY - rect.top,
      };
    };

    const drawStroke = (event) => {
      if (!isDrawing || !lastPoint) return;
      const rect = handwritingCanvas.getBoundingClientRect();
      const currentPoint = {
        x: event.clientX - rect.left,
        y: event.clientY - rect.top,
      };
      handwritingContext.beginPath();
      handwritingContext.moveTo(lastPoint.x, lastPoint.y);
      handwritingContext.lineTo(currentPoint.x, currentPoint.y);
      handwritingContext.stroke();
      lastPoint = currentPoint;
      hasDrawing = true;
    };

    const stopDrawing = () => {
      isDrawing = false;
      lastPoint = null;
    };

    const startCorrection = (event) => {
      isAnnotating = true;
      const rect = correctionCanvas.getBoundingClientRect();
      lastCorrectionPoint = {
        x: event.clientX - rect.left,
        y: event.clientY - rect.top,
      };
    };

    const drawCorrection = (event) => {
      if (!isAnnotating || !lastCorrectionPoint) return;
      const rect = correctionCanvas.getBoundingClientRect();
      const currentPoint = {
        x: event.clientX - rect.left,
        y: event.clientY - rect.top,
      };
      correctionContext.beginPath();
      correctionContext.moveTo(lastCorrectionPoint.x, lastCorrectionPoint.y);
      correctionContext.lineTo(currentPoint.x, currentPoint.y);
      correctionContext.stroke();
      lastCorrectionPoint = currentPoint;
      hasCorrections = true;
    };

    const stopCorrection = () => {
      isAnnotating = false;
      lastCorrectionPoint = null;
    };

    const clearLayer = (context) => {
      context.clearRect(0, 0, context.canvas.width, context.canvas.height);
    };

    const clearCharacterAnnotations = () => {
      characterAnnotations.innerHTML = '';
    };

    const renderAnalysisLayer = (ocrData) => {
      lastOcrData = ocrData;
      clearLayer(analysisContext);
      clearCharacterAnnotations();
      const entries = ocrData?.symbols?.length ? ocrData.symbols : ocrData?.words || [];
      if (!entries.length) {
        return;
      }
      const rect = analysisCanvas.getBoundingClientRect();
      const scaleX = rect.width / handwritingCanvas.width;
      const scaleY = rect.height / handwritingCanvas.height;
      analysisContext.fillStyle = 'rgba(239, 68, 68, 0.18)';
      analysisContext.strokeStyle = 'rgba(239, 68, 68, 0.9)';
      analysisContext.lineWidth = 1.5;
      entries.forEach((entry) => {
        if (!entry.bbox) return;
        const width = (entry.bbox.x1 - entry.bbox.x0) * scaleX;
        const height = (entry.bbox.y1 - entry.bbox.y0) * scaleY;
        const x = entry.bbox.x0 * scaleX;
        const y = entry.bbox.y0 * scaleY;
        analysisContext.fillRect(x, y, width, height);
        analysisContext.strokeRect(x, y, width, height);
      });
    };

    const renderCharacterAnnotations = (ocrData) => {
      clearCharacterAnnotations();
      if (!ocrData || !ocrData.symbols || !ocrData.symbols.length) {
        return;
      }
      const rect = analysisCanvas.getBoundingClientRect();
      const scaleX = rect.width / handwritingCanvas.width;
      const scaleY = rect.height / handwritingCanvas.height;
      ocrData.symbols.forEach((symbol) => {
        if (!symbol.bbox) return;
        const text = (symbol.text || '').trim();
        if (!text) return;
        const width = (symbol.bbox.x1 - symbol.bbox.x0) * scaleX;
        const height = (symbol.bbox.y1 - symbol.bbox.y0) * scaleY;
        const x = symbol.bbox.x0 * scaleX;
        const y = symbol.bbox.y0 * scaleY;
        const annotation = document.createElement('button');
        annotation.type = 'button';
        annotation.className = 'character-annotation';
        annotation.style.left = `${x}px`;
        annotation.style.top = `${y}px`;
        annotation.style.width = `${width}px`;
        annotation.style.height = `${height}px`;
        const label = document.createElement('span');
        label.className = 'character-annotation__label';
        label.textContent = text;
        annotation.appendChild(label);
        annotation.addEventListener('click', () => {
          label.hidden = true;
        });
        characterAnnotations.appendChild(annotation);
      });
    };

    const updatePreviewImage = (imageData) => {
      if (!imageData) {
        sourcePreview.removeAttribute('src');
        layeredPlaceholder.hidden = false;
        clearLayer(analysisContext);
        clearLayer(correctionContext);
        clearCharacterAnnotations();
        hasCorrections = false;
        return;
      }
      sourcePreview.src = imageData;
      layeredPlaceholder.hidden = true;
      sourcePreview.onload = () => {
        syncLayerCanvases();
      };
      syncLayerCanvases();
    };

    handwritingCanvas.addEventListener('pointerdown', (event) => {
      event.preventDefault();
      handwritingCanvas.setPointerCapture(event.pointerId);
      startDrawing(event);
    });
    handwritingCanvas.addEventListener('pointermove', (event) => {
      event.preventDefault();
      drawStroke(event);
    });
    handwritingCanvas.addEventListener('pointerup', stopDrawing);
    handwritingCanvas.addEventListener('pointercancel', stopDrawing);
    handwritingCanvas.addEventListener('pointerleave', stopDrawing);
    handwritingCanvas.addEventListener(
      'touchstart',
      (event) => {
        event.preventDefault();
      },
      { passive: false },
    );
    handwritingCanvas.addEventListener(
      'touchmove',
      (event) => {
        event.preventDefault();
      },
      { passive: false },
    );

    correctionCanvas.addEventListener('pointerdown', (event) => {
      event.preventDefault();
      correctionCanvas.setPointerCapture(event.pointerId);
      startCorrection(event);
    });
    correctionCanvas.addEventListener('pointermove', (event) => {
      event.preventDefault();
      drawCorrection(event);
    });
    correctionCanvas.addEventListener('pointerup', stopCorrection);
    correctionCanvas.addEventListener('pointercancel', stopCorrection);
    correctionCanvas.addEventListener('pointerleave', stopCorrection);

    clearDrawingButton.addEventListener('click', () => {
      resetCanvas();
      updatePreviewImage('');
      lastOcrData = null;
      status.textContent = '筆記入力をクリアしました。';
    });

    const extractBlock = (label, text) => {
      const pattern = new RegExp(`\\[${label}\\]([\\s\\S]*?)(?=\\n\\[[A-Z_]+\\]|$)`, 'i');
      const match = text.match(pattern);
      return match ? match[1].trim() : '';
    };

    const buildCompositeImage = () => {
      if (!hasCorrections || !correctionCanvas.width || !correctionCanvas.height) {
        return handwritingCanvas.toDataURL('image/png');
      }
      const compositeCanvas = document.createElement('canvas');
      compositeCanvas.width = handwritingCanvas.width;
      compositeCanvas.height = handwritingCanvas.height;
      const compositeContext = compositeCanvas.getContext('2d');
      compositeContext.drawImage(handwritingCanvas, 0, 0);
      const scaleX = handwritingCanvas.width / correctionCanvas.width;
      const scaleY = handwritingCanvas.height / correctionCanvas.height;
      compositeContext.save();
      compositeContext.scale(scaleX, scaleY);
      compositeContext.drawImage(correctionCanvas, 0, 0);
      compositeContext.restore();
      return compositeCanvas.toDataURL('image/png');
    };

    const runOcr = async () => {
      if (!hasDrawing) {
        return null;
      }
      status.textContent = '解読中…';
      const baseImageData = handwritingCanvas.toDataURL('image/png');
      updatePreviewImage(baseImageData);
      const ocrImageData = buildCompositeImage();
      if (!window.Tesseract) {
        status.textContent = 'OCR ライブラリの読み込みに失敗しました。';
        return null;
      }
      const result = await window.Tesseract.recognize(ocrImageData, 'jpn+eng', {
        logger: (message) => {
          if (message.status === 'recognizing text') {
            status.textContent = `解読中…${Math.round(message.progress * 100)}%`;
          }
        },
      });
      return {
        text: result.data.text.trim(),
        data: result.data,
      };
    };

    form.addEventListener('submit', async (event) => {
      event.preventDefault();
      const ocrResult = await runOcr();
      const rawText = ocrResult?.text ?? '';
      const blockInput = extractBlock('ORIGINAL_INPUT', rawText) || rawText;
      const resultText = blockInput || '（入力がありません）';

      output.textContent = `[DECODED_OUTPUT]\n${resultText}`;
      if (ocrResult?.data) {
        renderAnalysisLayer(ocrResult.data);
        renderCharacterAnnotations(ocrResult.data);
      } else {
        lastOcrData = null;
        clearLayer(analysisContext);
        clearCharacterAnnotations();
      }
      if (!rawText && !hasDrawing) {
        status.textContent = '筆記入力がありません。';
      } else {
        status.textContent = 'デコードが完了しました。';
      }
    });

    clearButton.addEventListener('click', () => {
      resetCanvas();
      output.textContent = '[DECODED_OUTPUT]\n（ここに結果が表示されます）';
      updatePreviewImage('');
      lastOcrData = null;
      clearLayer(analysisContext);
      clearLayer(correctionContext);
      clearCharacterAnnotations();
      hasCorrections = false;
      status.textContent = '';
    });

    toggleAnalysisButton.addEventListener('click', () => {
      analysisVisible = !analysisVisible;
      analysisCanvas.style.opacity = analysisVisible ? '1' : '0';
    });

    clearCorrectionsButton.addEventListener('click', () => {
      clearLayer(correctionContext);
      hasCorrections = false;
    });

    window.addEventListener('resize', () => {
      resizeCanvasForDisplay();
      syncLayerCanvases();
      if (lastOcrData) {
        renderAnalysisLayer(lastOcrData);
        renderCharacterAnnotations(lastOcrData);
      }
    });
    resizeCanvasForDisplay();
  </script>
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5.1.1/dist/tesseract.min.js" defer></script>
</body>
</html>
