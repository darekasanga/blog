<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>EMPEROR.NEWS | AI COVE-kun</title>
  <link rel="stylesheet" href="../assets/styles.css" />
</head>
<body class="home-page">
  <header class="site-header">
    <div class="inner">
      <div class="brand">
        <div class="brand-mark" aria-hidden="true"></div>
        <div>
          <p class="brand-kicker">BLOG</p>
          <p class="brand-title" data-site-title>EMPEROR.NEWS</p>
        </div>
      </div>
      <nav class="nav-links" aria-label="メインナビゲーション">
        <a href="../index.html" class="nav-link">トップ</a>
        <a href="../admin/index.html" class="nav-link">管理ページ</a>
        <a href="index.html" class="nav-link active">AI COVE-kun</a>
      </nav>
    </div>
  </header>

  <main>
    <section class="section">
      <div class="inner">
        <p class="kicker">AI COVE-kun</p>
        <h1>多言語デコード・アシスタント</h1>
        <p class="lead">原文を入力すると、指定フォーマットでデコード結果を整形して表示します。</p>
        <div class="info-grid" style="align-items: stretch;">
          <form class="info-card" id="decode-form">
            <div class="field">
              <label for="handwriting-canvas">ORIGINAL_INPUT (筆記入力)</label>
              <div class="handwriting-panel">
                <canvas id="handwriting-canvas" width="640" height="280" aria-label="原文の筆記入力エリア"></canvas>
                <div class="handwriting-actions">
                  <p class="muted-text">左側に手書きで文章を入力してください。描き終わったら「解読」を押してください。</p>
                  <button class="btn ghost" type="button" id="clear-drawing">筆記をクリア</button>
                </div>
              </div>
            </div>
            <p class="decode-status" id="decode-status" role="status" aria-live="polite"></p>
            <div class="form-actions">
              <button class="btn primary" type="submit">解読</button>
              <button class="btn ghost" type="button" id="clear-button">Clear</button>
            </div>
          </form>

          <div class="info-card">
            <div class="section-header">
              <div>
                <p class="kicker">Decoded</p>
                <h2>出力プレビュー</h2>
              </div>
            </div>
            <pre class="output-panel" id="decoded-output">[DECODED_OUTPUT]
（ここに結果が表示されます）</pre>
          </div>
        </div>
      </div>
    </section>

    <section class="section muted">
      <div class="inner">
        <div class="section-header">
          <div>
            <p class="kicker">Guideline</p>
            <h2>運用ルールの要点</h2>
          </div>
        </div>
        <div class="info-grid">
          <div class="info-card">
            <h3>優先順位</h3>
            <ul>
              <li>確定済みの学習ルールを最優先で適用。</li>
              <li>競合があれば文脈に合うものを選択。</li>
              <li>確信が低い場合は原文を保持。</li>
            </ul>
          </div>
          <div class="info-card">
            <h3>出力ルール</h3>
            <ul>
              <li>返答は <strong>[DECODED_OUTPUT]</strong> のみ。</li>
              <li>説明や補足は出力に含めない。</li>
              <li>多言語の混在を維持。</li>
            </ul>
          </div>
        </div>
      </div>
    </section>
  </main>

  <footer class="site-footer">
    <div class="inner footer-grid">
      <div>
        <p class="brand-title" data-site-title>EMPEROR.NEWS</p>
        <p class="muted-text" data-footer-description>シンプルで統一感のあるブログ体験を届けます。</p>
      </div>
      <div id="site-theme-picker" class="footer-theme-picker" aria-label="表示テーマ選択"></div>
    </div>
  </footer>

  <script>
    const form = document.getElementById('decode-form');
    const handwritingCanvas = document.getElementById('handwriting-canvas');
    const clearDrawingButton = document.getElementById('clear-drawing');
    const output = document.getElementById('decoded-output');
    const status = document.getElementById('decode-status');
    const clearButton = document.getElementById('clear-button');
    const handwritingContext = handwritingCanvas.getContext('2d');
    let isDrawing = false;
    let hasDrawing = false;
    let lastPoint = null;

    const resizeCanvasForDisplay = () => {
      const ratio = window.devicePixelRatio || 1;
      const { width, height } = handwritingCanvas.getBoundingClientRect();
      handwritingCanvas.width = Math.max(1, Math.floor(width * ratio));
      handwritingCanvas.height = Math.max(1, Math.floor(height * ratio));
      handwritingContext.setTransform(ratio, 0, 0, ratio, 0, 0);
      handwritingContext.lineWidth = 4;
      handwritingContext.lineCap = 'round';
      handwritingContext.lineJoin = 'round';
      handwritingContext.strokeStyle = '#111';
      handwritingContext.fillStyle = '#fff';
      handwritingContext.fillRect(0, 0, width, height);
      hasDrawing = false;
    };

    const resetCanvas = () => {
      const { width, height } = handwritingCanvas.getBoundingClientRect();
      handwritingContext.setTransform(window.devicePixelRatio || 1, 0, 0, window.devicePixelRatio || 1, 0, 0);
      handwritingContext.fillStyle = '#fff';
      handwritingContext.fillRect(0, 0, width, height);
      hasDrawing = false;
    };

    const startDrawing = (event) => {
      isDrawing = true;
      const rect = handwritingCanvas.getBoundingClientRect();
      lastPoint = {
        x: event.clientX - rect.left,
        y: event.clientY - rect.top,
      };
    };

    const drawStroke = (event) => {
      if (!isDrawing || !lastPoint) return;
      const rect = handwritingCanvas.getBoundingClientRect();
      const currentPoint = {
        x: event.clientX - rect.left,
        y: event.clientY - rect.top,
      };
      handwritingContext.beginPath();
      handwritingContext.moveTo(lastPoint.x, lastPoint.y);
      handwritingContext.lineTo(currentPoint.x, currentPoint.y);
      handwritingContext.stroke();
      lastPoint = currentPoint;
      hasDrawing = true;
    };

    const stopDrawing = () => {
      isDrawing = false;
      lastPoint = null;
    };

    handwritingCanvas.addEventListener('pointerdown', (event) => {
      handwritingCanvas.setPointerCapture(event.pointerId);
      startDrawing(event);
    });
    handwritingCanvas.addEventListener('pointermove', drawStroke);
    handwritingCanvas.addEventListener('pointerup', stopDrawing);
    handwritingCanvas.addEventListener('pointercancel', stopDrawing);
    handwritingCanvas.addEventListener('pointerleave', stopDrawing);

    clearDrawingButton.addEventListener('click', () => {
      resetCanvas();
      status.textContent = '筆記入力をクリアしました。';
    });

    const extractBlock = (label, text) => {
      const pattern = new RegExp(`\\[${label}\\]([\\s\\S]*?)(?=\\n\\[[A-Z_]+\\]|$)`, 'i');
      const match = text.match(pattern);
      return match ? match[1].trim() : '';
    };

    const runOcr = async () => {
      if (!hasDrawing) {
        return '';
      }
      status.textContent = '解読中…';
      const imageData = handwritingCanvas.toDataURL('image/png');
      if (!window.Tesseract) {
        status.textContent = 'OCR ライブラリの読み込みに失敗しました。';
        return '';
      }
      const result = await window.Tesseract.recognize(imageData, 'jpn+eng', {
        logger: (message) => {
          if (message.status === 'recognizing text') {
            status.textContent = `解読中…${Math.round(message.progress * 100)}%`;
          }
        },
      });
      return result.data.text.trim();
    };

    form.addEventListener('submit', async (event) => {
      event.preventDefault();
      const rawText = await runOcr();
      const blockInput = extractBlock('ORIGINAL_INPUT', rawText) || rawText;
      const resultText = blockInput || '（入力がありません）';

      output.textContent = `[DECODED_OUTPUT]\n${resultText}`;
      if (!rawText && !hasDrawing) {
        status.textContent = '筆記入力がありません。';
      } else {
        status.textContent = 'デコードが完了しました。';
      }
    });

    clearButton.addEventListener('click', () => {
      resetCanvas();
      output.textContent = '[DECODED_OUTPUT]\n（ここに結果が表示されます）';
      status.textContent = '';
    });

    window.addEventListener('resize', resizeCanvasForDisplay);
    resizeCanvasForDisplay();
  </script>
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5.1.1/dist/tesseract.min.js" defer></script>
</body>
</html>
